// Autogenerated by generateAst.fsx

import Foundation

protocol StmtVisitor {
    associatedtype StmtVisitorReturn
    func visitBlockStmt(_ stmt: Block) throws -> StmtVisitorReturn
    func visitExpressionStmt(_ stmt: Expression) throws -> StmtVisitorReturn
    func visitPrintStmt(_ stmt: Print) throws -> StmtVisitorReturn
    func visitVarStmt(_ stmt: Var) throws -> StmtVisitorReturn
}

// must be a base class, implementing Equatable does not work with protocol
class Stmt : Equatable {
   func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturn {
        preconditionFailure("base class cannot be used directly")
    }

    static func == (lhs: Stmt, rhs: Stmt) -> Bool {
        lhs.isEqualTo(rhs)
    }

    func isEqualTo (_ other: Stmt) -> Bool {
        preconditionFailure("base class cannot be used directly")
    }
}

class Block : Stmt {
    let statements: [Stmt]

    init(statements: [Stmt]) {
        self.statements = statements
    }

    override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturn {
        try visitor.visitBlockStmt(self)
    }

    override func isEqualTo (_ other: Stmt) -> Bool {
        guard let other = other as? Block else {return false}
        return self == other
    }

    static func == (lhs: Block, rhs: Block) -> Bool {
        return lhs.statements == rhs.statements
    }
}

class Expression : Stmt {
    let expression: Expr

    init(expression: Expr) {
        self.expression = expression
    }

    override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturn {
        try visitor.visitExpressionStmt(self)
    }

    override func isEqualTo (_ other: Stmt) -> Bool {
        guard let other = other as? Expression else {return false}
        return self == other
    }

    static func == (lhs: Expression, rhs: Expression) -> Bool {
        return lhs.expression == rhs.expression
    }
}

class Print : Stmt {
    let expression: Expr

    init(expression: Expr) {
        self.expression = expression
    }

    override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturn {
        try visitor.visitPrintStmt(self)
    }

    override func isEqualTo (_ other: Stmt) -> Bool {
        guard let other = other as? Print else {return false}
        return self == other
    }

    static func == (lhs: Print, rhs: Print) -> Bool {
        return lhs.expression == rhs.expression
    }
}

class Var : Stmt {
    let name: Token
    let initializer: Expr?

    init(name: Token, initializer: Expr?) {
        self.name = name
        self.initializer = initializer
    }

    override func accept<V: StmtVisitor, R>(visitor: V) throws -> R where R == V.StmtVisitorReturn {
        try visitor.visitVarStmt(self)
    }

    override func isEqualTo (_ other: Stmt) -> Bool {
        guard let other = other as? Var else {return false}
        return self == other
    }

    static func == (lhs: Var, rhs: Var) -> Bool {
        return lhs.name == rhs.name &&
               lhs.initializer == rhs.initializer
    }
}

