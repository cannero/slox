// Autogenerated by generateAst.fsx

import Foundation

protocol ExprVisitor {
    associatedtype ExprVisitorReturn
    func visitAssignExpr(_ expr: Assign) throws -> ExprVisitorReturn
    func visitBinaryExpr(_ expr: Binary) throws -> ExprVisitorReturn
    func visitGroupingExpr(_ expr: Grouping) throws -> ExprVisitorReturn
    func visitLiteralExpr(_ expr: Literal) throws -> ExprVisitorReturn
    func visitUnaryExpr(_ expr: Unary) throws -> ExprVisitorReturn
    func visitVariableExpr(_ expr: Variable) throws -> ExprVisitorReturn
}

// must be a base class, implementing Equatable does not work with protocol
class Expr : Equatable {
   func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        preconditionFailure("base class cannot be used directly")
    }

    static func == (lhs: Expr, rhs: Expr) -> Bool {
        lhs.isEqualTo(rhs)
    }

    func isEqualTo (_ other: Expr) -> Bool {
        preconditionFailure("base class cannot be used directly")
    }
}

class Assign : Expr {
    let name: Token
    let value: Expr

    init(name: Token, value: Expr) {
        self.name = name
        self.value = value
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitAssignExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Assign else {return false}
        return self == other
    }

    static func == (lhs: Assign, rhs: Assign) -> Bool {
        return lhs.name == rhs.name &&
               lhs.value == rhs.value
    }
}

class Binary : Expr {
    let left: Expr
    let op: Token
    let right: Expr

    init(left: Expr, op: Token, right: Expr) {
        self.left = left
        self.op = op
        self.right = right
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitBinaryExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Binary else {return false}
        return self == other
    }

    static func == (lhs: Binary, rhs: Binary) -> Bool {
        return lhs.left == rhs.left &&
               lhs.op == rhs.op &&
               lhs.right == rhs.right
    }
}

class Grouping : Expr {
    let expression: Expr

    init(expression: Expr) {
        self.expression = expression
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitGroupingExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Grouping else {return false}
        return self == other
    }

    static func == (lhs: Grouping, rhs: Grouping) -> Bool {
        return lhs.expression == rhs.expression
    }
}

class Literal : Expr {
    let value: LiteralValue?

    init(value: LiteralValue?) {
        self.value = value
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitLiteralExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Literal else {return false}
        return self == other
    }

    static func == (lhs: Literal, rhs: Literal) -> Bool {
        return lhs.value == rhs.value
    }
}

class Unary : Expr {
    let op: Token
    let right: Expr

    init(op: Token, right: Expr) {
        self.op = op
        self.right = right
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitUnaryExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Unary else {return false}
        return self == other
    }

    static func == (lhs: Unary, rhs: Unary) -> Bool {
        return lhs.op == rhs.op &&
               lhs.right == rhs.right
    }
}

class Variable : Expr {
    let name: Token

    init(name: Token) {
        self.name = name
    }

    override func accept<V: ExprVisitor, R>(visitor: V) throws -> R where R == V.ExprVisitorReturn {
        try visitor.visitVariableExpr(self)
    }

    override func isEqualTo (_ other: Expr) -> Bool {
        guard let other = other as? Variable else {return false}
        return self == other
    }

    static func == (lhs: Variable, rhs: Variable) -> Bool {
        return lhs.name == rhs.name
    }
}

